// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
:projectid: jax-rs-reactive-client
:page-layout: guide-multipane
:page-duration: 15 minutes
:page-releasedate: 2020-07-31
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use the reactive JAX-RS client to invoke RESTful microservices over HTTP asynchronously.
:page-seo-title: Consuming RESTful Java microservices asynchronously using default and third-party reactive JAX-RS client
:page-seo-description: A getting started tutorial and an example on how to consume RESTful Java microservices asynchronously using reactive Java API for RESTful Web Services (JAX-RS) client and Eclipse Jersey third-party reactive client library.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE']
:page-permalink: /guides/{projectid}
:page-related-guides: ['microprofile-reactive-messaging', 'microprofile-rest-client-async']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:mac: MAC
:win: WINDOWS
:linux: LINUX
= Consuming RESTful services using reactive JAX-RS client

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to use reactive JAX-RS client to invoke RESTful microservices over HTTP asynchronously.

== What you'll learn
You will learn how the default reactive JAX-RS client accesses remote RESTful services using asynchronous method calls. You will then learn how to update the client so that it uses custom objects from third-party libraries such as http://cxf.apache.org/docs/jax-rs.html[CXF^] or in this case https://eclipse-ee4j.github.io/jersey/[Jersey^]. You will also use this library to invoke your new client using Jersey’s custom invoker `RxObservableInvoker`.
You will then update your resources to accommodate the new client. Instead of using elementary, single-use asynchronous solutions, you will use asynchronous data streams to transport data. In doing so, you will learn the benefits of using the `Observable` class over the more traditional `CompletionStage` interface, like more scalable implementation. You will also gain exposure to the rich set of operators that the former includes.

The application you will be working with is a manager that maintains an inventory of available systems.
It consists of three microservices, `system`, `inventory`, and `query`. Every 15 seconds, the `system` microservice 
calculates and publishes an event that contains its current average system load. The `inventory` microservice subscribes 
to that information so that it can keep an updated list of all the systems and their current system loads.

image::QueryService.png[Reactive Query Service, width=253, height=327, align="center"]

The microservice that you will modify is the `query` service. It communicates with the `inventory` service 
to determine which system has the highest system load and which system has the lowest system load.

The implementations of the application and its services are provided for you in the `start` directory.
The `system` and `inventory` microservices uses MicroProfile Reactive Messaging to send and receive the system load events.
If you want to learn more about reactive messaging, you can read the 
https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating reactive Java microservices^] guide.

=== What is asynchronous programming?
Asynchronous programming can be thought of as a restaurant. After being seated, a waiter will take your order. At this point, you will have to wait a few minutes for your food to be prepared. While your food is being prepared your waiter may take more orders or serve other tables. Once your food is ready, your waiter will be notified to bring out your food. However, in a synchronous model, the waiter would have to wait for your food to be prepared before dealing with any other customers. This method blocks other customers from placing orders or receiving their food.

Asynchronous methods allow you to perform a lengthy operation, such as input/output (I/O) asynchronously. This means that the I/O occurs in the background and the caller is notified via a callback to continue with their computation once it’s complete. The benefit is that this frees up the original thread to handle other work rather than waiting on I/O to complete. Going back to the restaurant analogy, food is prepared asynchronously in the kitchen and your waiter is freed up to attend to other tables. Since they’re free, the waiter can take more orders from other tables, or serve food to other tables.

In the context of REST clients, making synchronous HTTP requests can be a time consuming process. The network may be slow, or maybe the upstream service is overwhelmed and can't respond quickly. These lengthy operations can block the execution of your thread when it's in use and prevent other work from being completed.

=== What is reactive programming?
Reactive programming is an extension of asynchronous programming and a model that concerns itself with the flow of data through data streams. Execution of the model advances only when new data becomes available. Any changes, once complete, are immediately transitioned through the model via data streams, thus making it generally easier to implement an asynchronous and non-blocking system.

Reactive programming brings with it many advantages. One of the greatest advantages of reactive programming is that you can focus mainly on business logic instead of having to worry about implementation and configuration. It is alot simpler to do asynchronous work and setup complex threading because reactive programming avoids the use of callbacks that asynchronous programming brings with itself. This also brings with it a much faster runtime execution of your application, which allows for a much better user experience. Lastly, it makes your code much more readable and easier to fix. You can add or remove blocks of code from individual data streams which means you can easily amend a specific, distressed stream. The usage of reactive streams brings with it tools to handle data flow, backpressure, thread safety, and error propagation. +

== Additional prerequisites

You need to have Docker installed. For installation instructions, refer to the official https://docs.docker.com/get-docker/[Docker documentation^]. You will build and run the microservices in Docker containers. An installation of Apache Kafka is provided in another Docker container.

// =================================================================================================
// Getting started
// =================================================================================================

[role='command']
include::{common-includes}/gitclone.adoc[]

== Using the default reactive JAX-RS client

InventoryClient.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::start/query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java[]
----

QueryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::start/query/src/main/java/io/openliberty/guides/query/QueryResource.java[]
----

Navigate to the `start` directory to begin.

An implementation of the default reactive JAX-RS client is already provided for you. The classes you will change are [hotspot file=0]`InventoryClient` and [hotspot file=1]`QueryResource` which now implement the default JAX-RS reactive client.

The [hotspot file=0]`InventoryClient` class is used to retrieve the inventory data. In the [hotspot file=0]`InventoryClient` class, notice how the [hotspot=getSystem file=0]`getSystem()` returns the `CompletionStage` interface. This interface represents a unit or stage of a computation, and once the associated computation completes, the value contained can be retrieved. Notice how it also contains an [hotspot=rx file=0]`rx()` call. This is the default reactive invoker for the `CompletionStage` interface and this method is what retrieves the `CompletionStageRxInvoker` class and allows for these methods to function correctly with the `CompletionStage` interface return type.

The [hotspot file=1]`QueryResource` class is used to process the data coming in from the data streams, which is accessed through the [hotspot file=0]`InventoryClient`. It serves this data when all of the services have completed execution. The [hotspot=thenAcceptAsync file=1]`thenAcceptAsync()` and [hotspot=exceptionally file=1]`exceptionally()` methods together behave like an asynchronous try-catch block. The data is processed in the [hotspot=thenAcceptAsync file=1]`thenAcceptAsync()` method, only when the `CompletionStage` interface has finished retrieving it. It is important to note that when you return a `CompletionStage` in the resource, it doesn't guarantee that computation is complete and that the response has been built. 

== Updating the client to use third-party libraries

JAX-RS supports the usage of third-party libraries like https://eclipse-ee4j.github.io/jersey[Jersey^]. Jersey provides a client-builder interface which allows users to make a request for the data. It allows the use of specific invokers as configuration so that the client can support https://github.com/ReactiveX/RxJava[RxJava^] objects instead of only the `CompletionStage` interface. These custom objects are useful for covering use cases that the `CompletionStage` interface cannot. 

The https://github.com/ReactiveX/RxJava[RxJava^] and required Jersey libraries are included as dependencies to your [hotspot file=0]`query/pom.xml` file. The [hotspot=67-71 file=0]`rxjava` dependency allows the application to use the https://github.com/ReactiveX/RxJava[RxJava^] API. The [hotspot=77-81 file=0]`jersey-rx-client-rxjava` and [hotspot=82-86 file=0]`jersey-rx-client-rxjava2` dependencies provide the Rx Invoker provider classes which are then registered to the [hotspot=72-76 file=0]`jersey-client` client-builder.

pom.xml
[source,xml,linenums,role="code_column"]
----
include::finish/query/pom.xml[tags=**]
----

Update the client to accommodate the custom object types that you are trying to return. Also register the type of object that you want inside the client invocation.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `InventoryClient` interface.#
`query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java`
----
InventoryClient.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java[]
----

The changes involve changing the return types of the [hotspot=getSystem file=1]`getSystem()` method from a `CompletionStage` interface to an `Observable` object. `http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html[Observable^]` is a collection of data that awaits to be subscribed to before it can release any data and is part of https://github.com/ReactiveX/RxJava[RxJava^]. The [hotspot=rx file=1]`rx()` invoker also must contain `RxObservableInvoker.class` as an argument. This is to invoke the specific invoker for the `Observable` class provided by Jersey. Notice in the [hotspot=webTarget file=1]`webTarget()` method, the [hotspot=register file=1]`register(RxObservableInvokerProvider)` call that allows for the client to recognize the `RxObservableInvoker` class. Without registering the invoker provider, the invoker will not be recognized.

Sometimes there are scenarios where a producer will generate more data than the consumers and handle. In cases like these, JAX-RS can deal with this issue using RxJava's `Flowable` with `backpressure`. You can learn more with this post about https://openliberty.io/blog/2019/04/10/jaxrs-reactive-extensions.html?fbclid=IwAR00IgA2lwRsp0_lRTOVTibTw7oZTwkHr_pCDLXKxIxwA8EgE_xrxk22r5A[JAX-RS reactive extensions with RxJava Backpressure^]


== Updating the client to use the reactive model

Now that the client methods return the `Observable` class, you must update the resource to accommodate these changes.

[role="code_command hotspot=0", subs="quotes"]
----
#Replace the `QueryResource` class.#
`query/src/main/java/io/openliberty/guides/query/QueryResource.java`
----
QueryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/main/java/io/openliberty/guides/query/QueryResource.java[]
----

Instead of using `thenAcceptAsync()`, observables use the [hotspot=subscribe file=0]`subscribe()` method to asynchronously process data. Thus any required processing of data will be performed in the [hotspot=subscribe file=0]`subscribe()` call. In this case, it is simply saving the data in the temporary [hotspot=holder hotspot=holderClass file=0]`holder`. The temporary holder is used to store the value returned from the client because values cannot be returned inside [hotspot=subscribe file=0]`subscribe()`. 

A [hotspot=countdownlatch file=0]`CountDownLatch` is used to keep track of how many asynchronous requests we are waiting on. The [hotspot=countdownlatch file=0]`CountDownLatch` will countdown towards 0 after the completion of a thread via the [hotspot=countdown file=0]`countdown` method call. This means that the value will only return once the thread that's retrieving the value is complete. Using the [hotspot=await file=0]`await` method, we stop and wait until all our requests are complete. While waiting for this countdown to complete, the main thread is free to perform other tasks. In this case, no such task is present, but a simple task can be given to occupy the thread.

// =================================================================================================
// Building the application
// =================================================================================================

== Building and running the application

The `system`, `inventory`, and `query` microservices will be built in a Docker container. If you want to learn more about Docker containers, you can check out the https://openliberty.io/guides/containerize.html[Containerizing microservices^] guide.

Start your Docker environment.

To build the application, run the Maven `install` and `package` goals from the command-line session in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

include::{common-includes}/ol-kernel-docker-pull.adoc[]

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t system:1.0-SNAPSHOT system/.
docker build -t inventory:1.0-SNAPSHOT inventory/.
docker build -t query:1.0-SNAPSHOT query/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and all of the microservices in the project.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

The services will take some time to become available.
You can access the application by making requests to the `query/systemLoad` endpoint by accessing http://localhost:9080/query/systemLoad[http://localhost:9080/query/systemLoad^]. 

When the service is ready, you will see an output similar to the one below. The given example has been formatted for readability.

[source, role='no_copy']
----
{ 
    "highest": {
        "hostname":"30bec2b63a96",       
        ”systemLoad": 6.1
    },     
    "lowest": { 
        "hostname":"55ec2b63a96",    
        ”systemLoad": 0.1
    }
}
----

The JSON output has a `highest` attribute which represents the system with the highest load. Similarly, the `lowest` attribute represents the system with the lowest load. The JSON output for each of these feature the respective hostname and systemLoad of the system.

Switching to a reactive programming model has freed up the thread handling your request to `/query/systemLoad`. While the client request is being handled, the thread can handle other work.

When you are done checking out the application, run the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

// =================================================================================================
// Testing
// =================================================================================================

== Testing the query microservice

A few tests are included for you to test the basic functionality of the `query` microservice. If a test failure occurs, then you may have introduced a bug into the code.

[role="code_command hotspot", subs="quotes"]
----
#Create the `QueryServiceIT` class.#
`query/src/test/java/it/io/openliberty/guides/query/QueryServiceIT.java`
----

The [hotspot=testLoads file=0]`testLoads()` test case verifies that the `query` service can correctly calculate the highest and lowest system loads. 

QueryServiceIT.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/test/java/it/io/openliberty/guides/query/QueryServiceIT.java[]
----


// =================================================================================================
// Running the tests
// =================================================================================================

=== Running the tests

Navigate to the `query` directory, then verify that the tests pass using the Maven `verify` goal:

[role='command']
```
mvn verify
```

When the tests succeed, you will see output similar to the following.

[source, role='no_copy']
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.query.QueryServiceIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.88 s - in it.io.openliberty.guides.query.QueryServiceIT

Results:

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

== Great work! You're done!

You have just modified an application to make HTTP requests using reactive JAX-RS client with Open Liberty and Jersey.

include::{common-includes}/attribution.adoc[subs="attributes"]
