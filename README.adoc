// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
:projectid: jax-rs-reactive-client
:page-layout: guide-multipane
:page-duration: 15 minutes
:page-releasedate: 2020-07-31
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use the reactive JAX-RS client to invoke RESTful microservices over HTTP asynchronously.
:page-seo-title: Consuming RESTful Java microservices asynchronously using default and third-party reactive JAX-RS client
:page-seo-description: A getting started tutorial and an example on how to consume RESTful Java microservices asynchronously using reactive Java API for RESTful Web Services (JAX-RS) client and Eclipse Jersey third-party reactive client library.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE']
:page-permalink: /guides/{projectid}
:page-related-guides: ['microprofile-reactive-messaging', 'microprofile-rest-client-async']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:mac: MAC
:win: WINDOWS
:linux: LINUX
= Consuming RESTful services using reactive JAX-RS client

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to use reactive JAX-RS client to invoke RESTful microservices over HTTP asynchronously.

== What you'll learn
The default JAX-RS client is an API used to communicate with RESTful web services. The API makes it very easy to consume a web service 
exposed via HTTP protocol and allowes developers to concisely and efficiently implement client side solutions. The Reactive client extension
is an API allowing users to utilize the reactive programming model when using JAX-RS client.

You will learn how the default reactive JAX-RS client accesses remote RESTful services using asynchronous method calls. You will then learn how to update the client so that it uses custom objects from third-party libraries such as http://cxf.apache.org/docs/jax-rs.html[CXF^] or in this case https://eclipse-ee4j.github.io/jersey/[Jersey^]. You will also use this library to invoke your new client using Jersey’s custom invoker `RxObservableInvoker`.
You will then update your resources to accommodate the new client. Instead of using elementary, single-use asynchronous solutions, you will use asynchronous data streams to transport data. In doing so, you will learn the benefits of using the `Observable` class over the more traditional `CompletionStage` interface, like more scalable implementation. You will also gain exposure to the rich set of operators that the former includes.

The application you will be working with is a manager that maintains an inventory of available systems.
It consists of three microservices, `system`, `inventory`, and `query`. Every 15 seconds, the `system` microservice 
calculates and publishes an event that contains its current average system load. The `inventory` microservice subscribes 
to that information so that it can keep an updated list of all the systems and their current system loads.

image::QueryService.png[Reactive Query Service, width=253, height=327, align="center"]

The microservice that you will modify is the `query` service. It communicates with the `inventory` service 
to determine which system has the highest system load and which system has the lowest system load.

The implementations of the application and its services are provided for you in the `start` directory.
The `system` and `inventory` microservices uses MicroProfile Reactive Messaging to send and receive the system load events.
If you want to learn more about reactive messaging, you can read the 
https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating reactive Java microservices^] guide.

== Additional prerequisites

You need to have Docker installed. For installation instructions, refer to the official https://docs.docker.com/get-docker/[Docker documentation^]. You will build and run the microservices in Docker containers. An installation of Apache Kafka is provided in another Docker container.

// =================================================================================================
// Getting started
// =================================================================================================

[role='command']
include::{common-includes}/gitclone.adoc[]

== Starting from the default reactive JAX-RS client

InventoryClient.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::start/query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java[]
----

QueryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::start/query/src/main/java/io/openliberty/guides/query/QueryResource.java[]
----

Navigate to the `start` directory to begin.

An implementation of the default reactive JAX-RS client is already provided for you. The classes you will change are [hotspot file=0]`InventoryClient` and [hotspot file=1]`QueryResource` which now implement the default JAX-RS reactive client.

The [hotspot file=0]`InventoryClient` class is used to retrieve the inventory data. In the [hotspot file=0]`InventoryClient` class, notice how the [hotspot=getSystem file=0]`getSystem()` returns the `CompletionStage` interface. This interface represents a unit or stage of a computation, and once the associated computation completes, the value contained can be retrieved. Notice how it also contains an [hotspot=rx file=0]`rx()` call. This is the default reactive invoker for the `CompletionStage` interface and this method is what retrieves the `CompletionStageRxInvoker` class and allows for these methods to function correctly with the `CompletionStage` interface return type.

The [hotspot file=1]`QueryResource` class is used to query data from the inventory service. The [hotspot=systemLoadMethod file=1]`systemLoad` endpoint processes the data, asynchronously, that is retrieved by the [hotspot=getsystem file=1]`InventoryClient`, as well as serves the data when all of the services have completed execution. The [hotspot=thenAcceptAsync file=1]`thenAcceptAsync()` and [hotspot=exceptionally file=1]`exceptionally()` methods together behave like an asynchronous try-catch block. The data is processed in the [hotspot=thenAcceptAsync file=1]`thenAcceptAsync()` method, only when the `CompletionStage` interface has finished retrieving it. It is important to note that when you return a `CompletionStage` type in the resource, it doesn’t necessarily mean that the computation completed and the response was built. A [hotspot=countdownlatch file=1]`CountDownLatch` is used to guarentee all of the requests have completed. This is something that will be reviewed further into the guide.

== Updating the default reactive client to use third-party libraries

JAX-RS supports the usage of third-party libraries like https://eclipse-ee4j.github.io/jersey[Jersey^]. Jersey provides a client-builder interface which allows users to make a request for the data. It allows the use of specific invokers as configuration so that the client can support https://github.com/ReactiveX/RxJava[RxJava^] objects instead of only the `CompletionStage` interface. These custom objects are useful for covering use cases that the `CompletionStage` interface cannot. 

The https://github.com/ReactiveX/RxJava[RxJava^] and required Jersey libraries are included as dependencies to your [hotspot file=0]`query/pom.xml` file. The [hotspot=67-71 file=0]`rxjava` dependency allows the application to use the https://github.com/ReactiveX/RxJava[RxJava^] API. The [hotspot=77-81 file=0]`jersey-rx-client-rxjava` and [hotspot=82-86 file=0]`jersey-rx-client-rxjava2` dependencies provide the Rx Invoker provider classes which are then registered to the [hotspot=72-76 file=0]`jersey-client` client-builder.

pom.xml
[source,xml,linenums,role="code_column"]
----
include::finish/query/pom.xml[tags=**]
----

Update the client to accommodate the custom object types that you are trying to return. Also register the type of object that you want inside the client invocation.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `InventoryClient` interface.#
`query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java`
----
InventoryClient.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java[]
----

The changes involve changing the return types of the [hotspot=getSystem file=1]`getSystem()` method from a `CompletionStage` interface to an `Observable` object. `http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html[Observable^]` is a collection of data that awaits to be subscribed to before it can release any data and is part of https://github.com/ReactiveX/RxJava[RxJava^]. The [hotspot=rx file=1]`rx()` invoker also must contain `RxObservableInvoker.class` as an argument. This is to invoke the specific invoker for the `Observable` class provided by Jersey. Notice in the [hotspot=webTarget file=1]`webTarget()` method, the [hotspot=register file=1]`register(RxObservableInvokerProvider)` call that allows for the client to recognize the `RxObservableInvoker` class. Without registering the invoker provider, the invoker will not be recognized.

Sometimes there are scenarios where a producer will generate more data than the consumers and handle. In cases like these, JAX-RS can deal with this issue using RxJava's `Flowable` with `backpressure`. You can learn more with this post about https://openliberty.io/blog/2019/04/10/jaxrs-reactive-extensions.html?fbclid=IwAR00IgA2lwRsp0_lRTOVTibTw7oZTwkHr_pCDLXKxIxwA8EgE_xrxk22r5A[JAX-RS reactive extensions with RxJava Backpressure^]


== Updating the resource that calls the reactive client

Now that the client methods return the `Observable` class, you must update the resource to accommodate these changes.

[role="code_command hotspot=0", subs="quotes"]
----
#Replace the `QueryResource` class.#
`query/src/main/java/io/openliberty/guides/query/QueryResource.java`
----
QueryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/main/java/io/openliberty/guides/query/QueryResource.java[]
----

The goal of the [hotspot=systemload file=0]`systemLoad()` method is to return the system with the largest load and the system with the smallest load. The `systemLoad` endpoint first gets all of the hostnames by calling [hotspot=getSystems file=0]`getSystems()`. Then it loops through each one and calls [hotspot=getSystem file=0]`getSystem()` on them.

Instead of using `thenAcceptAsync()`, `Observable` uses the [hotspot=subscribe file=0]`subscribe()` method to asynchronously process data. Thus any required processing of data will be performed in the [hotspot=subscribe file=0]`subscribe()` method. In this case, it is simply saving the data in the temporary [hotspot=holder hotspot=holderClass file=0]`holder`. The temporary holder is used to store the value returned from the client because values cannot be returned inside [hotspot=subscribe file=0]`subscribe()`. The highest and lowest load systems are updated in the [hotspot=updateHighestCall hotspot=updateHighestMethod file=0]`updateHighest()` and [hotspot=updateLowestCall hotspot=updateLowestMethod file=0]`updateLowest()` methods respectively.

A [hotspot=countdownlatch file=0]`CountDownLatch` is used to keep track of how many asynchronous requests we are waiting on. The [hotspot=countdownlatch file=0]`CountDownLatch` will countdown towards 0 after the completion of a thread via the [hotspot=countdown hotspot=countdown2 file=0]`countdown` method call. This means that the value will only return once the thread that's retrieving the value is complete. Using the [hotspot=await file=0]`await` method, we stop and wait until all our requests are complete. While waiting for this countdown to complete, the main thread is free to perform other tasks. In this case, no such task is present, but a simple task can be given to occupy the thread.

// =================================================================================================
// Building the application
// =================================================================================================

== Building and running the application

The `system`, `inventory`, and `query` microservices will be built in a Docker container. If you want to learn more about Docker containers, you can check out the https://openliberty.io/guides/containerize.html[Containerizing microservices^] guide.

Start your Docker environment.

To build the application, run the Maven `install` and `package` goals from the command-line session in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

include::{common-includes}/ol-kernel-docker-pull.adoc[]

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t system:1.0-SNAPSHOT system/.
docker build -t inventory:1.0-SNAPSHOT inventory/.
docker build -t query:1.0-SNAPSHOT query/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and all of the microservices in the project.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

The services will take some time to become available.
You can access the application by making requests to the `query/systemLoad` endpoint by accessing http://localhost:9080/query/systemLoad[http://localhost:9080/query/systemLoad^]. 

When the service is ready, you will see an output similar to the one below. The given example has been formatted for readability.

[source, role='no_copy']
----
{ 
    "highest": {
        "hostname":"30bec2b63a96",       
        ”systemLoad": 6.1
    },     
    "lowest": { 
        "hostname":"55ec2b63a96",    
        ”systemLoad": 0.1
    }
}
----

The JSON output has a `highest` attribute which represents the system with the highest load. Similarly, the `lowest` attribute represents the system with the lowest load. The JSON output for each of these feature the respective hostname and systemLoad of the system.

Switching to a reactive programming model has freed up the thread handling your request to `/query/systemLoad`. While the client request is being handled, the thread can handle other work.

When you are done checking out the application, run the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

// =================================================================================================
// Testing
// =================================================================================================

== Testing the query microservice

A few tests are included for you to test the basic functionality of the `query` microservice. If a test failure occurs, then you may have introduced a bug into the code.

[role="code_command hotspot", subs="quotes"]
----
#Create the `QueryServiceIT` class.#
`query/src/test/java/it/io/openliberty/guides/query/QueryServiceIT.java`
----

The [hotspot=testSystemLoad file=0]`testSystemLoad()` test case verifies that the `query` service can correctly calculate the highest and lowest system loads. 

QueryServiceIT.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/test/java/it/io/openliberty/guides/query/QueryServiceIT.java[]
----


// =================================================================================================
// Running the tests
// =================================================================================================

=== Running the tests

Navigate to the `query` directory, then verify that the tests pass using the Maven `verify` goal:

[role='command']
```
mvn verify
```

When the tests succeed, you will see output similar to the following.

[source, role='no_copy']
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.query.QueryServiceIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.88 s - in it.io.openliberty.guides.query.QueryServiceIT

Results:

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

== Great work! You're done!

You have just modified an application to make HTTP requests using reactive JAX-RS client with Open Liberty and Jersey.

include::{common-includes}/attribution.adoc[subs="attributes"]
