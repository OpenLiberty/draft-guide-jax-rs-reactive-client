// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
:projectid: reactive-rest-client
:page-layout: guide-multipane
:page-duration: 25 minutes
:page-releasedate: 2020-07-31
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to write a reactive JAX-RS client to asynchronously call RESTful microservices over HTTP.
:page-seo-title: Consuming RESTful Java microservices asynchronously using the reactive JAX-RS client
:page-seo-description: A getting started tutorial and an example on how to consume RESTful Java microservices asynchronously using reactive Java API for RESTful Web Services (JAX-RS) client and with Eclipse Jersey/RxJava reactive client library.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE']
:page-permalink: /guides/{projectid}
:page-related-guides: ['microprofile-reactive-messaging', 'microprofile-rest-client-async']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:mac: MAC
:win: WINDOWS
:linux: LINUX
= Consuming RESTful services using the reactive JAX-RS client

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to use a reactive JAX-RS client to invoke RESTful microservices over HTTP asynchronously.

== What you'll learn
You'll learn how to create a reactive JAX-RS client application using two different JAX-RS reactive providers, Apache CXF and Eclipse Jersey. The JAX-RS client is an API used to communicate with RESTful web services. The API makes it very easy to consume a web service exposed using the HTTP protocol and means that you can efficiently implement client-side applications. The reactive client extension to JAX-RS is an API that enables you to use the reactive programming model when using the JAX-RS client.

Reactive programming is an extension of asynchronous programming and focuses on the flow of data through data streams. Reactive application process data when it becomes available and responds to requests as soon as the processing is complete; the request and response to the application are decoupled so that the application is not blocked from responding to other requests in the meantime. Reactive applications can run faster than synchronous applications, which provides a much smoother user experience.

The application in this guide demonstrates how the JAX-RS client accesses remote RESTful services using asynchronous method calls. You'll first take a look at the supplied client application which uses CXF, the JAX-RS reactive provider used by default in Open Liberty, then you'll modify the client application to instead use Jersey, an alternative JAX-RS reactive provider. Both CXF and Jersey provide third-party reactive libraries, including RxJava, and have been tested for use in Open Liberty.

The application you will be working with consists of three microservices, `system`, `inventory`, and `query`. 
Every 15 seconds, the `system` microservice calculates and publishes an event that contains its current average system load. 
The `inventory` microservice subscribes to that information so that it can keep an updated list of all the systems and their 
current system loads.

image::QueryService.png[Reactive Query Service, width=253, height=327, align="center"]

The microservice that you will modify is the `query` service. It communicates with the `inventory` service 
to determine which system has the highest system load and which system has the lowest system load.

The `system` and `inventory` microservices uses MicroProfile Reactive Messaging to send and receive the system load events.
If you want to learn more about reactive messaging, you can read the 
https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating reactive Java microservices^] guide.

== Additional prerequisites

You need to have Docker installed. For installation instructions, refer to the official https://docs.docker.com/get-docker/[Docker documentation^]. You will build and run the microservices in Docker containers. An installation of Apache Kafka is provided in another Docker container.

// =================================================================================================
// Getting started
// =================================================================================================

[role='command']
include::{common-includes}/gitclone.adoc[]

== Creating a web client using the CXF reactive provider

Navigate to the `start` directory to begin.

The CXF reactive provider is provided by default in Open Liberty so that you can write application using reactive APIs like RxJava. Create an [hotspot file=0]`InventoryClient` class which is used to retrieve the inventory data, and a [hotspot file=1]`QueryResource` class, which queries data from the Inventory service.

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `InventoryClient` interface.#
`query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java`
----

The [hotspot=getSystem file=0]`getSystem()` method returns the `CompletionStage` interface. This interface represents a unit or stage of a computation and, when the associated computation completes, the value contained can be retrieved. The [hotspot=rx file=0]`rx()` method calls the `CompletionStage` interface. It retrieves the `CompletionStageRxInvoker` class and allows for these methods to function correctly with the `CompletionStage` interface return type.

[role="code_command hotspot=0", subs="quotes"]
----
#Create the `QueryResource` class.#
`query/src/main/java/io/openliberty/guides/query/QueryResource.java`
----

The [hotspot=systemLoadMethod file=1]`systemLoad` endpoint asynchronously processes the data that is retrieved by the [hotspot=getsystem file=1]`InventoryClient` and serves the data when all of the services have responded. The [hotspot=thenAcceptAsync file=1]`thenAcceptAsync()` and [hotspot=exceptionally file=1]`exceptionally()` methods together behave like an asynchronous try-catch block. The data is processed in the [hotspot=thenAcceptAsync file=1]`thenAcceptAsync()` method only when the `CompletionStage` interface has finished retrieving it. When you return a `CompletionStage` type in the resource, it doesn’t necessarily mean that the computation completed and the response was built.

A [hotspot=countdownlatch file=1]`CountDownLatch` object is used to keep track of how many asynchronous requests are being waited on. The [hotspot=countdownlatch file=1]`CountDownLatch` object will countdown towards 0 after the completion of a thread via the [hotspot=countdown1 hotspot=countdown2 file=1]`countdown` method call. This means that the value will only return once the thread that's retrieving the value is complete. The [hotspot=await file=1]`await` method stops and waits until all of the requests have completed. While waiting for this countdown to complete, the main thread is free to perform other tasks. In this case, no such task is present, but a simple task can be given to occupy the thread.

InventoryClient.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::defaultrx/query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java[]
----

QueryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::defaultrx/query/src/main/java/io/openliberty/guides/query/QueryResource.java[]
----

== Building and running the application

The `system`, `inventory`, and `query` microservices will be built in a Docker container. If you want to learn more about Docker containers, you can check out the https://openliberty.io/guides/containerize.html[Containerizing microservices^] guide.

Start your Docker environment.

To build the application, run the Maven `install` and `package` goals from the command-line session in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

include::{common-includes}/ol-kernel-docker-pull.adoc[]

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t system:1.0-SNAPSHOT system/.
docker build -t inventory:1.0-SNAPSHOT inventory/.
docker build -t query:1.0-SNAPSHOT query/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the containers to communicate with each other. It creates containers for Kafka, Zookeeper, and all of the microservices in the project.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

The services will take some time to become available.
You can access the application by making requests to the `query/systemLoad` endpoint by accessing http://localhost:9080/query/systemLoad[http://localhost:9080/query/systemLoad^]. 

When the service is ready, you will see an output similar to the one below. The given example has been formatted for readability.

[source, role='no_copy']
----
{ 
    "highest": {
        "hostname":"30bec2b63a96",       
        ”systemLoad": 6.1
    },     
    "lowest": { 
        "hostname":"55ec2b63a96",    
        ”systemLoad": 0.1
    }
}
----

The JSON output has a `highest` attribute which represents the system with the highest load. Similarly, the `lowest` attribute represents the system with the lowest load. The JSON output for each of these feature the respective hostname and systemLoad of the system.

When you are done checking out the application, run the following command to stop the query microservice. We will leave the `system` and `inventory` services running because we will use them when we rebuild the application later on. 

--
[role='command']
```
docker stop query
```
--


== Updating the web client to use an alternative reactive provider

Although Open Liberty provides the Apache CXF JAX-RS reactive provider by default, you can alternatively use another provider, such as Eclipse Jersey or RESTEasy, which also support the use of https://github.com/ReactiveX/RxJava[RxJava^] reactive libraries. You'll now update the the web client to use the Jersey reactive provider instead of CXF. This means that you can write clients that use RxJava objects instead of just the CompletionStage interface. These custom objects provide a simpler and faster way for you to create scalable RESTful services over a CompletionStage interface.

[role="code_command hotspot=2", subs="quotes"]
----
#Update the `pom.xml` file.#
`query/pom.xml`
----
pom.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/pom.xml[]
----

The [hotspot=rxjava file=2]`rxjava` dependency allows the application to use the RxJava API. The [hotspot=jerseyRxjava file=2]`jersey-rx-client-rxjava` and [hotspot=jerseyRxjava2 file=2]`jersey-rx-client-rxjava2` dependencies provide the Rx Invoker provider classes which are then registered to the [hotspot=jerseyClient file=2]`jersey-client` client-builder.

Update the client to accommodate the custom object types that you are trying to return. You'll need to register the type of object that you want inside the client invocation.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `InventoryClient` interface.#
`query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java`
----
InventoryClient.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java[]
----

The return types of the [hotspot=getSystem file=0]`getSystem()` method are now an `Observable` object instead of a `CompletionStage` interface. http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html[Observable^] is a collection of data that awaits to be subscribed to before it can release any data and is part of RxJava. The [hotspot=rx file=0]`rx()` method now needs to contain `RxObservableInvoker.class` as an argument. This is to call the specific invoker, `RxObservableInvoker`, for the Observable class provided by Jersey. In the [hotspot=getSystem file=0]`getSystem()` method, the [hotspot=register file=0]`register(RxObservableInvokerProvider)` call registers the `RxObservableInvoker` class, which means that the client can recognize the invoker provider.

Sometimes there are scenarios where a producer will generate more data than the consumers can handle. In cases like these, JAX-RS can deal with this issue using RxJava's `Flowable` with `backpressure`. You can learn more with this post about https://openliberty.io/blog/2019/04/10/jaxrs-reactive-extensions.html?fbclid=IwAR00IgA2lwRsp0_lRTOVTibTw7oZTwkHr_pCDLXKxIxwA8EgE_xrxk22r5A[JAX-RS reactive extensions with RxJava Backpressure^]

== Updating the REST resource to support the reactive JAX-RS client

Now that the client methods return the `Observable` class, you must update the resource to accommodate these changes.

[role="code_command hotspot=1", subs="quotes"]
----
#Replace the `QueryResource` class.#
`query/src/main/java/io/openliberty/guides/query/QueryResource.java`
----
QueryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/main/java/io/openliberty/guides/query/QueryResource.java[]
----

The goal of the [hotspot=systemload file=1]`systemLoad()` method is to return the system with the largest load and the system with the smallest load. The `systemLoad` endpoint first gets all of the hostnames by calling [hotspot=getSystems file=1]`getSystems()`. Then it loops through each one and calls [hotspot=getSystem file=1]`getSystem()` on them.

Instead of using `thenAcceptAsync()`, `Observable` uses the [hotspot=subscribe file=1]`subscribe()` method to asynchronously process data. Thus, any required processing of data will be performed inside the `subscribe()` method. In this case, it is simply saving the data in the temporary [hotspot=holderClass file=1]`holder` class. The temporary `holder` class is used to store the value returned from the client because values cannot be returned inside the `subscribe()` method. The highest and lowest load systems are updated in the [hotspot=updateHighestMethod file=1]`updateHighest()` and [hotspot=updateLowestMethod file=1]`updateLowest()` methods respectively.

== Re-Building and running the application

Run the Maven `install` and `package` goals from the command-line session in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

Run the following command to containerize the query microservices:

[role='command']
```
docker build -t query:1.0-SNAPSHOT query/.
```

Next, use the provided script to restart the query service in a Docker container. 

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startQueryContainer.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startQueryContainer.bat
```
--

You can access the application by making requests to the `query/systemLoad` endpoint by accessing http://localhost:9080/query/systemLoad[http://localhost:9080/query/systemLoad^]. 

Switching to a reactive programming model has freed up the thread handling your request to `/query/systemLoad`. While the client request is being handled, the thread can handle other work.

When you are done checking out the application, run the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

// =================================================================================================
// Testing
// =================================================================================================

== Testing the query microservice

A few tests are included for you to test the basic functionality of the `query` microservice. If a test failure occurs, then you may have introduced a bug into the code.

[role="code_command hotspot", subs="quotes"]
----
#Create the `QueryServiceIT` class.#
`query/src/test/java/it/io/openliberty/guides/query/QueryServiceIT.java`
----

The [hotspot=testSystemLoad file=0]`testSystemLoad()` test case verifies that the `query` service can correctly calculate the highest and lowest system loads. 

QueryServiceIT.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/test/java/it/io/openliberty/guides/query/QueryServiceIT.java[]
----


// =================================================================================================
// Running the tests
// =================================================================================================

=== Running the tests

Navigate to the `query` directory, then verify that the tests pass using the Maven `verify` goal:

[role='command']
```
mvn verify
```

When the tests succeed, you will see output similar to the following.

[source, role='no_copy']
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.query.QueryServiceIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.88 s - in it.io.openliberty.guides.query.QueryServiceIT

Results:

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

== Great work! You're done!

You have just modified an application to make HTTP requests using a reactive JAX-RS client with Open Liberty and Jersey.

include::{common-includes}/attribution.adoc[subs="attributes"]
